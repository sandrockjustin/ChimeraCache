const os = require('node:os');

class Oracle {
  /**
   * These private properties are specific to how ChimeraCache operates and attempts tracking of
   * memory within the constraints of the JavaScript language. They are also used to facilitate the
   * operations of the interrogator instance.
   */
  #chimeraMemory = 0;

  #percentChimeraSystemUsage = 0;   // Percent of memory ChimeraCache is occupying on system
  #percentChimeraProcessUsage = 0;  // Percent of memory ChimeraCache is using of NodeJS process


  /**
   * These private properties are mainly generated by NodeJS to help initialize our environment.
   * All of these fields are absolutely vital to ChimeraCache as they enable it to adapt to the
   * needs of an end-users' requirements.
   */
  #systemMemory = os.totalmem();
  #unallocatedMemory = os.freemem();
  #allocatedMemory = this.#systemMemory - this.#unallocatedMemory;
  #processMemory = process.memoryUsage().rss;

  #percentSystemUsage = this.#allocatedMemory / this.#systemMemory; // Percent of total system memory in use
  #percentProcessUsage = this.#processMemory / this.#systemMemory;

  /**
   * The Oracle object is instanced by the Interrogator of ChimeraCache; it is responsible for
   * performance metrics including fallback, overflow, and bytesize interrogations.
   * @param {*} options 
   */
  constructor(options = {}) {

    /**
     * Will receive the following, eventually:
     * - byteSize and byteRatio constraints [min/max]
     * - fallback thresholds [min/max] for [system, process, chimera: [system, process] ]
     */

  }

  /**
   * Updates all values associated with ChimeraCache's performance metrics.
   */
  #update() {
    this.#systemMemory = os.totalmem();
    this.#unallocatedMemory = os.freemem();
    this.#allocatedMemory = this.#systemMemory - this.#unallocatedMemory;
    this.#processMemory = process.memoryUsage().rss;
    
    /**
     * Why are we doing this? Well, it's because of how NodeJS OS modules work. They account for
     * actual allocated memory, but some systems (such as Windows) do not count 'Standby' memory
     * that is used for caching as 'memory that is in use' which skews metrics. This is not a 
     * perfect solution, which is why future versions of ChimeraCache will be JavaScript speaking
     * with performant C/C++ code that has better access to these kinds of data.
     */
    this.#percentSystemUsage = (this.#allocatedMemory + this.#chimeraMemory) / this.#systemMemory;

    this.#percentProcessUsage = this.#processMemory / this.#systemMemory;
    this.#percentChimeraSystemUsage = this.#chimeraMemory / this.#systemMemory;
    this.#percentChimeraProcessUsage = this.#chimeraMemory / this.#processMemory;
  }

  /**
   * Updates (adds to) the approximated amount of bytes in use by ChimeraCache.
   * @param {*} bytes 
   * @returns 
   */
  allocate(bytes) {

    if (this.#violation(bytes)) {
      return false;
    }

    this.#chimeraMemory += bytes;
    this.#update();
    return true;
  }

  /**
   * Updates (subtracts from) the approximated amount of bytes in use by ChimeraCache.
   * @param {*} bytes 
   * @returns 
   */
  free(bytes) {
    if (this.#violation(bytes)) {
      return false;
    }

    this.#chimeraMemory -= bytes;
    this.#update();
    return true;
  }

  /**
   * Determines whether the provided data will violate byte constraints.
   * @param {} bytes 
   */
  #violation(bytes) {
    // Must check to see if bytes violate cache constraints
      // If constraints violated, return TRUE
      // If constraints respected, return FALSE
  }

}